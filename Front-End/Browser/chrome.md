# 输入URL到页面展示

从输入 URL 到页面展示的这一过程，可分为导航过程（从输入url到获取资源）和渲染过程（解析资源）。前提知识是了解浏览器架构。

重点知识在渲染过程，比如页面是如何工作的，有了这些知识，就可以解决一系列相关的问题：熟练使用开发者工具，能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。

## 1. 浏览器架构

- **浏览器进程（Browser Process）**：负责页面展示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程（安全的沙箱模式 sandbox）**：默认情况下 Chrome 会为 每个 Tab 标签创建一个渲染进程，负责将 HTML、CSS、和 JavaScript 转化为网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是在该进程中。

- **网络进程**：面向渲染进程和浏览器进程等提供网络下载功能。
- **GPU 进程**：网页和 Chrome 的 UI 界面都是采用 GPU 来绘制。  
- **插件进程（sandbox）**：负责插件的运行，为了安全所以运行在沙箱模式下，插件进程独立出来使得插件崩溃不会影响到网页。

## 2. 导航过程
1. 用户输入（browser：生成url，改变浏览器交互状态）
2. 请求过程（通过 IPC 把URL发送给网络进程）：网络进程判断是否有缓存、DNS，从而建立TCP连接。
3. 服务器响应请求，网络进程获取到响应数据，读取响应头 为200 ok，无重定向等信息，通知 browser进程。
4. browser主进程收到通知，开始创建子进程--渲染进程。
5. browser 向渲染进程发出“提交文档”的消息，随后渲染进程和网络进程创建传输数据的“管道”。
6. 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给browser，随后进入“渲染过程”阶段。
7. brower收到“确认提交”后，更新浏览器界面状态，包括地址栏的urul、安全状态等。

## 3. 渲染过程
按照渲染的时间顺序，可分为几个阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

**构建 DOM 树**    
因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为能够理解的结构——DOM 树：HTML 文件（输入）-->HTML解析器（输出）-->DOM。

**样式计算（Recalculate Style）**    
样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

1. 把 CSS 转换为浏览器能够理解的结构：CSS 文本（输入）--> styleSheets。（三种css来源）
2. 转换样式表中的属性值，使其标准化。（css单位）
3. 计算出 DOM 树中每个节点的具体样式。（css继承和叠层规则）

**布局**    
计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。在布局阶段需要完成两个任务：创建布局树和布局计算。

1. 创建布局树: DOM 树含有很多不可见的元素，比如 head 标签,所以在显示之前，还要额外地构建一棵只包含可见元素布局树。为了构建布局树，浏览器遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉。
2. 布局计算： 有了完整的布局树，接下来就要计算布局树节点的坐标位置。
   
**分层**    
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。正是这些图层叠加在一起构成了最终的页面图像。

**图层绘制**          
在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎实现图层，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

**栅格化（raster）操作**  
绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，通常一个页面可能很大，我们把用户可以看到的这个部分叫做视口（viewport）。  有的图层可以很大，用户只能看到页面的很小一部分，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile）。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，通常栅格化过程都会使用 GPU 来加速，生成的位图被保存在 GPU 内存中。

**合成和显示**     
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。



**总结**    
- 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 4. 页面性能    

**使用Chrome 开发者工具做性能分析**    

暂时略

**JavaScript对DOM树构建的影响**        

HTML 解析器根据网络进程加载了多少数据，HTML 解析器便解析多少数据，而不是等整个 HTML 文档加载完成之后才开始解析的。具体过程为，网络进程通过管道给渲染进程传输字节流的时，渲染进程动态接收并且使用HTML解析器将字节流（Bytes）解析为DOM（具体过程略，可查看资料）。

HTML 解析器在进行 DOM 解析过程中，遇到 JavaScript（script标签）就会停止DOM解析，执行JavaScript（若是通过src引用外部文件会去先下载，这很耗时，chrome对此做了预解析优化，当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。

**CSS 对首次加载时的白屏时间的影响**  

要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。


**系统的优化界面**    
通常一个页面有三个阶段：加载阶段、交互阶段、关闭阶段

加载阶段： 从发出请求到渲染出完整页面的过程。
交互阶段: 从页面加载完成到用户交互的整合过程。
关闭阶段：用户发出关闭指令后页面所作出的一些清理操作。

## 5. 页面循环过程

