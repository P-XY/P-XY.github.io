# 递归

**递归需要满足的三个条件**

1. 一个问题的解,可以拆分为多个子问题的解。
2. 这个问题和拆分的子问题，除了数据规模不一样，求解思路完全一样。
3. 存在递归终止条件。

## 1. 编写递归

**编写递归最关键的步骤是，写出递归公式，和找到终止条件。**

>例子：假如这里有 n 个台阶，每次可以跨 1 或 2 个台阶，求 n 个台阶有多少种走法？      
 
**步骤1，找出递归公式：**

把所有走法分为两类，一类是第一步走了 1 个台阶，那么剩下 n-1 个台阶的走法。
第二类是第一步走了 2 个台阶，那么剩下 n-2 个台阶的走法。而 n 个台阶，一共有f(n)个走法，
得出递归公式： 
```js
f(n) = f(n-1) + f(n-2) 
```

**步骤2，找到终止条件：**

当 n=1 时，f(1)=1 。只有一个台阶式时只有一种走法，没必要再继续递归,所以 f(1)=1 是一个终止条件； 

当 n=2 时，f(2) = f(1) + f(0) ，只有一个 f(1) 终止条件时，f(2) 无法求解，还需要一个 f(0) 终止条件。  f(0)=1 表示走 0 个台阶只有一个走法，但并不符合正常的逻辑思维，都 0 个台阶了怎么还可以走？ 所以我们把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。

**步骤3，代码实现：**

把递归公式和终止条件放在一起是这一个的：
```js
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```
有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：
```js
function f(n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```
**总结**   

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

但是，当我们面对的是，一个问题要分解为多个子问题，而不只是一个子问题的情况，递归代码就没那么好理解了。

如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，

**因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。

## 2. 递归注意事项

递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。

>防止堆栈溢出

- 可以在代码中限制递归调用的最大深度的方式来解决这个问题，
但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。或者计算的代价太大，太复杂。
- 使用缓存计算，去除冗余计算。

> 把递归改为非递归

- 用“循环+递推”代替递归；笼统地讲，因为递归本身就是借助栈来实现的，所有的递归代码都可以改为迭代循环。递归一般是自顶向下，而递推的方式是自底向上。


## 4. 递归的练习题

1. 用递归实现斐波那契数列，要求去除递归带来的冗余计算，并实现缓存结果。
2. 用递推的方式实现斐波那契数列。
3. n 个台阶，假如一次可以跳 1 或者 2 阶，求所有跳法。
4. 用递归实现单链表的反转。
5. 




- 栗子1: 常规斐波那契
```js
//斐波那契数列: 0 , 1, 1 ,2 ,
function fibonacci( n ){
    if(n < 1){ return 0 }
    if(n <= 2){ return 1 }
    return fibonacci( n-1 ) + fibonacci( n-2 )
}
```

- 栗子2：使用缓存去冗余计算的斐波那契
```js
function fibonacciMemoization(n) {
  if (n < 1) { return 0 }
  let memo = [0, 1]
  function fibonacciMem(num){
    if (memo[num] != null) { return memo[num] }
    return (memo[num] = fibonacciMem(num - 1) + fibonacciMem(num - 2))
  };
  return fibonacciMem(n);
}
```

- 栗子3：带缓存结果的最终版斐波那契
```js
function memoizer(fun) {
    let cache = {}
    return function (n) {
        if (cache[n] != undefined) {
            return cache[n]
        } else {
            let result = fun(n)
            cache[n] = result
            return result
        }
    }
}
// 使用栗子2中的fibonacciMemoization
fibonacci = memoizer(fibonacciMemoization)
fibonacci(5)
fibonacci(10)
fibonacci(5)
```


































## 参考

- [Web 性能优化：理解及使用 JavaScript 缓存](https://mp.weixin.qq.com/s/PEjEfP9HwqnYt34YN6E8Zw)
- [Fibonacci(斐波那契数列)的最佳实践方式(JavaScript)](https://www.cnblogs.com/iriszhang/p/6093175.html)
- [尾递归为啥能优化？](https://zhuanlan.zhihu.com/p/36587160)