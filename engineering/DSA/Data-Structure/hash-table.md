# 散列表（Hash Table，也叫哈希表）

>  [Map、Dictionary、Hash Table 有哪些异同？](https://www.zhihu.com/question/27581780)

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

## 1. 散列函数

实现散列表，需要一个散列函数，函数接受不同的参数，计算出不同的散列值，而散列值就类似数组的下标，通过散列值就能找到key对应的值。总的来说： hashFunc( args ) --> hash_Index --> hashList[ ... ]    

三点散列函数设计的基本要求：
1. 散列函数计算得到的散列值是一个非负整数。
2. 如果 key1 = key2，那 hash(key1) == hash(key2)。
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

前面1、2很好理解，但第三点，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，
像业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种散列冲突，所以针对散列冲突问题，我们需要通过其他途径来解决。

## 2. 散列冲突

再好的散列函数也无法避免散列冲突。常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）

1. 开放寻址法

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
比如有**线性探测（Linear Probing）**，**二次探测（Quadratic probing）**和**双重散列（Double hashing）**

2. 链表法

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。

## 3. 实现工业级的散列表

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。

首先，散列函数的设计不能太复杂。 
其次，散列函数生成的值要尽可能随机并且均匀分布。

对于装载因子过大，导致散列冲突的问题，需要动态扩容，但是要避免低效的扩容。    

**如何选择冲突解决方案？**      

当数据量比较小、装载因子小的时候，适合采用开放寻址法。
基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

**工业级的散列表应该具有哪些特性？**  
- 支持快速地查询、插入、删除操作；
- 内存占用合理，不能浪费过多的内存空间；
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

**如何实现这样一个散列表呢？**
- 设计一个合适的散列函数；
- 定义装载因子阈值，并且设计动态扩容策略；
- 选择合适的散列冲突解决方法。

**工业级散列表举例分析：Java 中的 HashMap**
1. 初始大小    
HashMap 默认的初始大小是 16，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数。
2. 装载因子和动态扩容    
最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小
3. 散列冲突解决方法    
HashMap 底层采用链表法来解决冲突，而当链表长度太长（默认超过 8）时，链表就转换为红黑树。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显
4. 散列函数     
散列函数的设计并不复杂，追求的是简单高效、分布均匀

## 3. 散列表代码实现
- [HashTable](https://github.com/wangzheng0822/algo/blob/master/javascript/19_hashTable/hashtable.js)

## 4. 哈希（散列）算法

哈希算法的应用非常非常多，最常见的七个，分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。

要想设计一个优秀的哈希算法，需要满足的几点要求：
- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
- 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

