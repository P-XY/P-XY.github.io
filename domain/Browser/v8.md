# V8 工作原理（JS 执行机制）

> 怎么学习 V8 ?

V8 的主要职责是用来执行 JavaScript代码，所以我们需要先了解 **JavaScript 基本特征和设计思想**。

之后就可以学习 V8 执行 JavaScript 的代码的完整流程，我们把这套流程称之为 **V8 的编译流水线**。V8 流水线本身并不复杂，
但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等。

要想充分了解 V8 是怎么工作的，除了要分析编译流水线，我们还要了解**事件循环系统**和**垃圾回收机制**。
事件循环系统与 JavaScript 中的难点 ———— 异步编程特性相关。 JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，
会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，我们需要知道 V8 是如何分配内存数据的，以及这些
数据如何被回收，当遇到内存问题时，就知道如何去排查了。

> V8 是如何执行一段 JavaScript 代码的？

大部分高级语言的两种执行方式，解释执行和编译执行：
1. 输入一段代码 -> 解释器 -> 中间代码 ->解释器 -> 输出结果
2. 输入一段代码 -> 解释器 -> 中间代码 ->编译器 ->机器代码 ->计算机执行->输出结果

V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用的技术称为 JIT(JUST In Time)技术。
* 输入一段代码 -> 解释器（AST 和作用域）-> 中间码（字节码）-> 解释器（输出结果，或者发现热点代码 ->编译器 -> 机器码 ->输出结果）。

## 1. JavaScript 设计思想（JavaScript 核心）

### 1.1 函数即对象：彻底搞懂 JavaScript 函数的特点（什么是对象）
JavaScript 中的函数非常灵活，其根本原因在于 JavaScript 中的函数就是一种特殊的对象，我们把 JavaScript 中的函数称为
一等公民（First Class Function）。基于函数是一等公民的设计，使得JavaScript非常容易实现一些特性，比如闭包，还有函数式编程，
而其他语言，比如 C++ 中实现闭包需要实现大量复杂的代码，而且使用起来特别复杂。

> 什么是 JavaScript 中的对象？

JavaScript 是一种基于对象（Object-Based）的语言，但它却不是一门**面向对象的语言（Object-Oriented Programming Languge）**，
因为面向对象天生支持封装、继承、多态，但是 JavaScript 没有直接提供多态的支持。除了对多态支持的不好，JavaScript 实现继承的方式和面向对象的语言实现继承的方式同样存在很大差异。比如 Java 会提供 public、interface 等关键字，使得使用继承变得复杂和繁琐，而JavaScript 的基于原型的继承方式非常清爽简单。

既然 “JavaScript 中的对象” 和 “面向对象语言中的对象” 存在巨大差异，那么 JavaScript 中，我们谈论的对象到底是指什么？
JavaScript 中的对象非常简单，**对象就是属性和值构成的集合，属性值有三种类型：基本数据类型、对象、函数。函数是一种特殊的对象，和普通对象不同的是，函数可以被调用**。

> 那么在 V8 内部是怎么实现函数可调用特性呢？   

**其实V8 在内部，为函数对象提供了两个隐藏属性，分别是 name 和 code**。 隐藏的 name 属性的值就是函数名，如果某个
函数没有设置函数名，该 name 属性值就为 anonymous,表示该函数对象没有设置名称。 code 属性值表示函数代码，以字符串形式存储
在内存中，当执行到一个函数调用语句时， V8 便会从函数对象中取出 code 属性值，然后再执行这段函数代码。

> 怎么理解 “JavaScript 中的函数是一等公民”？

JavaScript 中的函数可以赋值给一个变量，也可以作为函数的参数或返回值。**如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民**。 支持函数是一等公民的语言可以使得代码逻辑更加清晰，代码更加简洁。

但是由于函数额“可被调用” 的特性，使得函数的可赋值、可作为传参和可作为返回值等特性变得有一些麻烦，因为在执行 JavaScript 函数的
过程中，为了实现变量的查找，V8 会为其维护一个作用域链，当虚拟机需要处理函数引用的外部变量，就会一层层往上查找作用域。 我们把这种将外部变量和函数绑定起来的技术称为闭包。

### 1.2 快属性和慢属性：V8 采用了哪些策略提升了对象属性的访问速度？（怎么存储对象）

从 JavaScript 语言的角度来看，JavaScript 的对象像一个字典，字符串作为键名，任意对象可以作为键值。
然而 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考虑，因为字典是非线性的数据结构，查询效率会低于线性的
数据结构，V8 为了提升存储和查找的效率，采用了一套复杂的存储策略。

> 常规属性（properties）和排序属性（element）？

在 ECMAScript 规范中定义了 **数字属性应该按照索引值大小升序排序，字符串属性根据创建时的顺序升序排序** 。
在 V8 实现中，数字属性就是排序属性，被称为 elements；字符串属性就是常规属性，被称为 properties。 
为了有效的提升和访问这两种属性的性能，v8 分别使用了两个 **线性数据结构** 来分别保存排序属性（采用数组？）和常规属性（采用队列或栈？）。

将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步辨别
properties / element 的操作，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。

基于这个原因，V8 采用了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，
我们把这称为 **对象内属性（in-object properties）**， 对象内属性的数量是固定的，默认是 10 个，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。

> 快属性和慢属性？

通常，我们将保存在线性数据结构中的属性称之为“快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。

因此，如果一个对象的属性过多时，V8 为就会采取另外一种存储策略，那就是“慢属性”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。

总结：
 
通过引入 element 和 properties 两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率， 
V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。
但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。

参考：[V8 是怎么跑起来的 —— V8 中的对象表示](https://zhuanlan.zhihu.com/p/98434092)

### 1.3  函数表达式：函数表达式怎么学？（变量提升的本质）

> 变量提升的内部机制？

如果是一个普通变量，变量提升之后的值都是 undefined（包括以函数表达式的方式赋值的变量），如果是声明的函数，那么变量提升之后的值则是函数对象。说明V8 对于提升函数和提升变量的策略是不同的。

这是为什么呢？ 这就是涉及到表达式和语句的区别了。 简单地理解，表达式就是表示值的式子（会返回一个值），而语句是操作值的式子（不会返回值）。
函数声明是一个语句，当 V8 执行到函数声明时，V8 并没有返回任何的值，它只是解析函数，并将函数对象存储在内存中。

比如：
```js
var x = 7
//等价于
var x // 变量提升阶段(编译阶段)，该阶段只会分析基础的语句，V8把这些变量存放在作用域时，还会赋一个默认值 undefined
x = 7 // 执行阶段，所有的表达式都是在执行阶段完成的
```
**语句的分析是在编译阶段，V8 把变量存放在作用域并赋值 undefined （函数声明是个特殊例外，V8 会在内存中声明生成函数对象，并将该对象提升到作用域中）。而所有的表达式，都是在执行阶段完成的**。函数声明是语句，函数表达式是表达式。

那么v8 怎么处理函数表达式的呢？在编译阶段，V8 不会处理表达式，所以不会把函数表达式提升到作用域中，依旧只是给变量赋值一个 undefined。

立即调用的函数表达式是怎么实现的？ 正是利用了 V8 在编译阶段不会处理表达式这个特性实现的。JavaScript 中有一个圆括号运算符，括号里面必须一个表达式，整个语句也是一个表达式：
```js
// 如果在小括号中间存放的是一个函数声明，V8 会把这个函数看成是函数表达式，执行时它会返回一个函数。
//因为括号里面的是一个函数表达式，它会返回一个函数，那么在表达式后面加上调用括号，这就称：立即调用函数表达式
(funciton(){
    //statements
})()
```
因为函数立即调用表达式也是表达式，所以在编译阶段，V8 为该表达式创建函数对象，这样的一个好处是：
**不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到**，在 ES6 之前，JavaScript 中没有私有作用域的概念，
使用函数立即表达式就可以用来封装一些变量、函数，可以起到变量隔离和代码隐藏的作用，因此在一些大的开源项目中有广泛的应用。
另外，因为函数立即表达式是立即执行的，所以将一个函数立即表达式赋给一个变量时，不是存储本身，而是执行结果。

### 1.4 原型链：V8 是如何实现对象继承的？（基于原型的面向对象）

简单地理解，继承就是一个对象可以访问另外一个对象中的属性和方法。不同的语言实现继承的方式是不同的，其中最典型的两种方式是基于类的设计和基于原型继承的设计。在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。

不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的。

参考：[用自己的方式（图）理解constructor、prototype、__proto__和原型链](https://juejin.im/post/6844903837623386126)

### 1.5 作用域链：V8 是如何查找变量的（静态作用域）

作用域就是存放变量和函数的地方，作用域链就是将一个个作用域串起来，实现变量查找的路径。

略。

### 1.6 类型转换：V8 是怎么实现 1 + “2” 的？（类型系统）

掌握：JavaScript 对类型的转换规则。

js, 在做运算的时候,都要以原始类型进行运算。
V8 通过toPrimitive函数将其转换为原始类型(先valueOf,再toString,如果获取不到原始类型数据就会抛出TypeError错误)

如果有字符串，则把另一种数据类型转换为字符串再操作。其他情况则转为数字。

在执行加法过程中，V8 会先通过 ToPrimitive 函数，将对象转换为原生的字符串或者是数字类型，在转换过程中，ToPrimitive 会先调用对象的 valueOf 方法，如果没有 valueOf 方法，则调用 toString 方法，如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误

## 2. V8 编译流水线

### 2.1 运行时环境：运行 JavaScript 代码的基石

在执行 JavaScript 代码之前，V8 就已经准备好了代码的运行时环境，这个环境包括了：
**堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统**。
准备好运行时环境之后，V8 才可以执行 JavaScript 代码，这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作。

* 运行时环境（这里要讲的） -> 解析 -> 生成字节码 -> 解释执行 -> 编译执行

> 宿主环境（NodeJs或者浏览器）和 V8 的关系？

浏览器为 V8 提供基础的消息循环系统、全局变量、Web API。而 V8 的核心是实现了 ECMAScript 标准，提供了 ECMAScript 定义的一些对象和一些核心的函数，这包括了 Object、Function、String，除此之外，还提供了垃圾回收器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行。

> 宿主环境为 V8 执行 JavaScript 时提供了哪些部件？

* 构造数据存储空间：堆空间和栈空间
      
    在 Chrome 中，只要打开一个渲染进程，渲染进程便会初始化 V8，同时初始化堆空间和栈空间。

    栈空间主要是用来管理 JavaScript 函数调用的，在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比
    如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个
    函数执行结束，那么该函数的执行上下文便会被销毁掉。栈空间的最大的特点是空间连续，因此，V8 对栈空间
    的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。

    堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，诸如函数、数组，在浏览器中还有 window 对象、
    document 对象等，这些都是存在堆空间的。

    宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。 

   

* 全局执行上下文和全局作用域 

    V8 初始化了基础的存储空间之后，接下来就需要初始化全局执行上下文和全局作用域了。

### 2.2 堆和栈：函数调用时如何影响内存布局的？




### 2.3 延迟解析：V8 是如何实现闭包的？

 参考：[JS 变量存储？栈 & 堆？NONONO!](https://juejin.im/post/6844903997615128583) ,文中有些错误。 

### 2.4 V8 为什么引入字节码？


### 2.5 隐藏类：如何在内存中快速查找对象属性？


## 3. 事件循环和垃圾回收

### 3.1 消息队列：V8怎么实现函数回调的？

### 3.2 异步编程1：V8 如何实现微任务的？

### 3.3 异步编程2：V8 如何实现asynca/await ?

从回调函数(回调地狱) -> promise（微任务，线性回调但依旧不够直观） -> generator/yield 协程（暂停函数执行，使得可以用同步方式写异步） -> async/await（微任务 promise 和 协程 generator 的结合）

### 3.4 垃圾回收1：V8 的两个垃圾回收器是如何工作的？

### 3.5 垃圾回收2：V8 是如何优化垃圾回收器执行效率的？
